# 실용주의 프로그래머
##### 앤드류 헌트, 데이비드 토마스 지음

이 책은 프로그램의 내외에서 어떻게 실용적인 프로그램을 해야 하는 지를 알려주는 책이다. 프로그래밍에서의 팁과, 프로그램을 진행하는 과정에서의 팁을 알기 쉽게 얘기해준다. 개인적으로 이 책을 읽는 내내 느낀 점은 팁을 얘기하고 그 팁에 대해서 설명해줄 때, 나는 어떻게 하고 있는가를 생각하고 반성하고 자극했던 책이었던 것 같다. 내가 알고 있는 것, 그리고 책에서 읽으면서 새로 배운 것들을 정리했고 내가 알고 있는 것에 대해서는 그 글을 읽고 어떻게 생각했는 지에 대해 그렇지 않은 부분보다 더 개인적인 생각을 적었다. 이 책을 읽으면서, 책의 끝이 무슨 얘기로 마무리가 될까 궁금했는데, 그 끝이 코드의 소유권이었던 것이 특히 인상적이었다.  

### 1. 실용주의 철학

이 파트에서는 소통에 대해서 강조를 했다고 생각한다. 나도 항상 느끼는 부분이지만, 프로그래밍을 잘 모르는 사람은 하나의 컴퓨터와 하나의 사람만이 필요하다고 생각하는 경우가 종종 있다. 하지만 프로그래밍을 하면서 잘 모르는 부분이 있거나, 이 문제에 대해서 또 다른 생각의 접근으로 코드를 짤 수 있는 경우가 있지 않을까라는 생각이 들 때거나, 에러가 났을 때 혼자 해결하지 못할 때 등등 나는 사람들과 많이 얘기했다. 그리고 사람들의 조언과 또 다른 관점에서의 생각이 보다 유용할 때도 있었고 그렇게 하나씩 소통해서 경험이 늘어감으로써, 나는 생각의 폭이 더 넓어지고, 코딩도 더 다양해지고 여러모로 많이 배울 수 있었다고 생각한다. 그래서 프로그래밍은 소통 또한 매우 중요한 요소라고 생각했는데 이 책에서도 그렇게 말해서 굉장히 공감되었다.
프로그래밍은 빠르게 변화하고 있고 새로운 언어가 등장하고 새로운 이론이 나오는 등 굉장히 빠르게 변화하는 필드라고 생각한다. 그래서 계속해서 공부해야하는 직업이 프로그래머라고 생각한다. 책에서도 성실한 공부를 하라고 조언하는데, 공부는 여러 가지로부터 배울 수 있다. 예를 들어, 책과 수업이 있을 수 있고 아니면 사람들과의 모임에서도 배울 수 있다. 책과 수업은 초등학생 때부터 공부를 배울 수 있는 매개체였지만 사람들과의 모임은 나에게 달랐던 경험이다. 제작년에 지인의 추천으로 facebook에서 TensorFlow Korea와 Python Korea 등등을 가입한 적이 있다. 우리 또래의 페이스북은 사실 하나의 엔터테인 어플이고 친구들과만 소통을 하는 곳이기도 하였다. 하지만 이러한 페이지, 그룹 등을 가입하고 나서 내 뉴스피드에 모임들의 얘기, 새로운 이슈, 안 풀리는 점 등이 올라오는 것을 보게 되면서 새로운 이슈라던지 논문이라던지 내가 이해하기엔 어렵고 무슨 말을 하는 지는 정확하게는 모르겠지만 이런 게 있구나 하는 생각이 들고 또 어떤 이슈에 대해선 이런 것도 재밌겠다 라는 생각이 들기도 했다. 내가 알고 있는 세상까지가 아닌 더 큰 세상에서 사람들은 이러한 얘기를 하고 있다는 사실이 센세이션했다. 책에서 "지역 사용자 모임에 참여하라"라는 제안에서 또 한 번 나의 경험을 떠올리게 되었다.

### 2. 실용주의 접근법

이번 파트는 개발 중에 발생하는 아이디어와 프로세스에 대해서 얘기한다.   
- 중복  
중복이라는 단어를 보자마자 내가 생각한 중복은 메모리의 낭비였다. 하지만 책에서는 메모리의 낭비 뿐만 아니라 개발자들간의 코드 쉐어링 과정에서의 중복, 실수의 중복, 또 부족한 시간의 프로젝트에서 발생하는 중복 코드 사용 등이 있다. 가장 인상적인 중복은 개발자들간의 중복이다. 책에서는 이러한 중복을 해결하기 위해서 애초에 코드를 재사용하기 쉽게 만들라고 조언한다. 이 중복이 인상적이었던 이유는 아직 나는 내가 짠 코드를 남들이 재사용한 경험이 없다. 오히려 나는 남들이 만든 코드 중 하나의 함수만을 불러온다던지 그러한 경험이 있어도 나의 코드 중 하나의 함수를 다른 사람들이 코드에 직접 쓴 경험은 없다. 그래서 재사용하기 쉽게라는 말을 곰곰히 생각해보았다. 너무 전체 코드에만 맞추어서 전체 코드를 돌리지 않으면 실행하기 복잡한 함수가 아닌 이 전체 코드는 필요하지 않고 어떤 함수만 필요한 사람 또한 쉽게 사용할 수 있는 코드를 만들어야한다는 생각도 포함해야한다는 생각이 들었다. 그러한 생각이 들고나서 만난 두 번째 아이디어는 직교성이었다. 여기서 직교성이란 아까의 나의 생각과 유사한 아이디어라고 생각한다. 직교성은 두 개의 직선이 하나의 점에서 직교하고 어떠한 방향으로 움직여도 두 직선은 또 다른 점에서 접하지 않는다. 이 말은 두 직선이 서로 독립적이라고 말할 수 있다. 프로그래밍에서는 이러한 개념을 하나의 코드가 있을 경우, 수정이 필요할 때, 한번의 수정으로 코드 전체가 어그러지는 것이 아니라 딱 수정이 필요한 부분만 필요할 수 있도록 짜는 것이 좋은 개발의 팁이라고 말한다. 결국 전체 코드가 있을 때 함수와 함수를 최대한 독립적으로 짜는 것이 포인트라고 생각한다. 이것이 앞서 말했듯이, 중복 또한 줄여줄 수 있고 재사용하기 쉽게 재수정하기 쉽게 만들어줄 수 있다고 생각했다.   

- 가역성   
프로그래밍에서 가역성이란, 이런 경우에서도 저런 경우에서도 이 코드가 잘 돌아갈 수 있게끔 유연한 코드를 짜는 것이다. 개인적으로 나는 이 부분에서 특히 소통이 필요하다고 생각한다. 왜냐하면 한 사람이 갖고 있는 접근 방법들이 모든 경우의 수가 아니고 또 다른 사람은 다르게 생각할 수 도 있기 때문에 여러 가지 의견 반영을 통해서 유연한 코드를 만들어내는 것이 좋다고 생각한다. 물론, 많은 사람들과 얘기를 한다고 해서 완벽한 유연한 코드가 아니라는 것은 분명하다. 하지만 어떠한 문제가 생길 때 바로바로 해결하여 보다 발전시키면 되는 부분이라고도 생각한다.  

- 예광탄   
예광탄이라고 표현은 했으나, 사실은 베이스라인이라고 생각하면 되지 않을까 싶다. 프로젝트 진행 중 내가 하고 있는 것이 맞는 지, 나는 어디쯤에 있는 지를 알고 싶을 때 지금 하고 있는 것을 베이스라인하고 해서 한 번 뽑아본다. 그러면 내가 의도하고 있는 것이 제대로 되고 있는 지, 무엇이 추가되어야할 지 등 여러가지 다음의 시도들이 try될 수있다. 오랫동안 코드를 짜는 것보단 중간중간에 결과값을 내보는 것도 매우 중요하다고 생각한다. 오랫동안 힘들게 다 짰는데 나중에 알고보니 빈 그릇일 수도 있고 또 아무 값이 없이 코딩만 하는 것도 프로그래머가 중간에 질릴 수 있기 떄문이다. 또 예광탄의 다른 좋은 점은 남들에게 보여줄 수 있다는 것이다. 연구실에서 교수님께 중간 보고를 드릴 때 항상 지금까지 한 것의 결과를 들고간다. 이것이 결국 프로젝트에서의 내 status라고 생각한다. 그래서 나만 일하는 것이 아닌 환경에서는 더더욱 내가 지금까지 한 일에 대해서 보고를 할 때는 이러한 일이 꼭 필요하다고 생각한다. 아마 회사에서도 그러지 않을까싶다.  

- 프로토 타입  
 프로토 타입 과정은 개인적으로 내가 좋아하는 과정이다. 프로토 타입을 만들어낸다는 것은 물론 남들에게 보여줄 수 있도록 하는 작업일 수도 있겠지만 나한테는 조금 다르다. 프로토 타입은 공책에 앞으로의 프로젝트를 어떻게 설계할 것인지 어떻게 하면 좋은 지 많은 생각을 하고 적어보고 그려보고 하면서 흰 종이에 알차게 내용이 적혀진다. 나는 이 과정에서 설렘을 느끼는 데 왜냐하면 나는 이것이 하나의 새로운 프로젝트가 시작되는 생각도 들고, 어떻게 설계하는 것이 맞는지 여러가지 경우의 버전으로 만들어보고, 또 내가 쓸 수 있는 어떤 다른 사람이 만든 코드가 무엇이 있는지, 즉, 내가 쓸 자원이 있나 확인하는 과정 등이 될 수 있다. 그리고 확실히 어디엔가 나의 생각을 적거나 그림으로써, 오히려 내가 채워간다는 느낌이 든다. 표현하지 않는 생각들은 잘 까먹을 수도 있고 서로 연결되어있는 많은 생각들은 정리가 쉽게 되지 않는다. 그래서 나는 항상 공책을 두어서 내 생각의 정리를 많이 했는데 이것이 참 좋은 방법같다고 생각한다. 그렇게 프로젝트에 대한 모델링이 끝나고 나면 깔끔하게 다시 정리해서 후에 보고를 올린다던가, 아니면 모델링에서 실제로 구현을 할 경우 일이 막혔을 때, 다른 사람에게 조언을 구하고 싶은 경우, 나의 프로토 타입을 보여주면서 그 사람이 알아야하는 부분만을 구술적뿐만 아니라 시각적으로도 알려줌으로써 보다 빠르게 다른 사람에게 나의 질문을 이해시킬 수 있다는 경험이 있다.

- 도메인 언어   
제시되어있는 요구사항이나 문제해결방법에 대해서 가장 완벽하게 프로그래밍을 하는 것이다. 이 때, 각자가 쓰는 언어의 특성에 따라 또 프로그래밍이 달라지는 것이어서 본인이 쓰는 언어에 대한 지식이 있어야지 보다 더 완벽한 프로그래밍을 할 수 있을 것이다.

- 추정  
실용주의 접근법에서 가장 해보지 않았던 것이 바로 추정이다. 추정은 결과값이 오래 걸려 나오는 모델이 언제 쯤 결과를 줄 지 또는  프로젝트의 일정시간을 추정하는 것이 있을 수 있다. 시간이 오래 걸려 나오는 모델같은 경우, 언제쯤 내가 결과값을 갖을 수 있을 지를 추정하는 것인데 이 떄 많은 사람은 한 번의 iteration이 얼만큼 걸리는 지를 각각의 iter에 시간을 출력해본다. 하지만 나는 이게 좋은 생각일까라는 의구심이 든다. 왜냐하면 for구문에서 출력을 내는 것은 시간이 오히려 더 걸릴 수 있다. 즉, 출력문을 삽입함으로써 모델의 한번의 iter에 걸리는 시간이 오래 걸릴 수 있다. 하지만 마냥 결과값만을 기다리는 것이 좋지 않음은 알고 있다. 다른 경우의 추정은 이 프로젝트가 언제쯤 무엇을 하게 될 지이다. 언제 이 프로젝트를 완수할 수 있을 지가 가장 중요한 것인다. 책에서는 비슷한 일을 해본 사람에게 물어보라고 했다. 그것도 하나의 추정방법일 수 있다고 생각한다. 하지만 나는 그 값이 실제값에 안 가까운 추정값이 될 거라고 생각한다. 왜냐하면 사람마다 잘하는 게 다르고 사람마다 일하는 게 다르기 때문이다. 그래서 추정은 내가 가장 불확실하게 생각하는 것이라고 생각한다. 내가 생각한 추정 날짜를 넘어가는 경우도 있기 때문이다. 내가 생각하는 가장 가까운 추정치를 도출해낼 수 있는 것은 결국 경험의 쌓임이라고 생각한다.

### 3. 기본적인 도구
이 파트에서는 기본 도구 세트를 늘 쓸 수 있도록 예리하게 유지하는 것이고 어떠한 도구에 어떻게 투자할 것인지에 대해 이야기한다.
- 명령어 셸   
파이썬의 명령어 셸로서는 window는 명령프롬프트를 열고, linux에서는 터미널을 열어서 python을 명령하여 사용한다.

- 에디터  
파이썬 에디터로는 jupyter notebook, pycharm과 atom을 사용한다. 주로 jupyter notebook을 사용하고 메모리 에러가 날 경우나 어떠한 경우에 놓이면 atom을 사용한다. 마크다운의 경우에는 atom을 사용한다.

- 소스코드관리  
전체 중 어떤 코드를 삭제하고 수정하여 저장하고 실행시킨 다음, 이 코드가 아닌 이전 코드가 더 맞다는 생각이 들 때, 돌아갈 수 없는 상황에 놓여있을 때 정말 당황한다. 그리고 이런 경우가 아니더라도, 테스트 삼아 만든 코드가 이후에 다시 재사용할 수 있을 수도 있는 여러가지 경우가 생김으로써, 그 파일들은 그대로 온전히 저장되어야할 가치가 있다. 이러한 저장을 위해서 책에서는 소스코드 관리 시스템을 사용하라고 한다. 나는 사용해본 경험은 없지만 책에서 알려준 url주소의 소스코드 관리 시스템을 사용해보고 싶다. 왜냐하면 나는 자주 복사본을 만드는 좋다고 할 수 도 없고 안 좋다고도 할 수 없는 습관이 있기 때문이다. 이런 시스템이 있는 지 몰랐는데 다음에 프로젝트를 하게되면 시도해보고싶다.

- 디버깅  
코드를 실행하고 나서 코드 속의 버그들이 잡힌다. 그 버그들을 잡는 것이 디버깅이라고 한다. 이 버그를 다른 말로는 에러라고도 말할 수있다. 실행 후 에러가 잡히면 왜 에러가 났는지 에러명이 출력이 되고 어느 라인에서 났는지도 표기가 된다. 이러한 에러명을 보고 간단하게 고칠 수 있는 에러가 있을 수도 있고, 시간이 아주 오래 걸리고 정교한 에러가 있을 수도 있다. 그리고 문제가 없음을 확신했는데 에러가 나고 당황해서 에러를 찾지만 못 찾는, 하지만 알고보면 정말 한 글자만 틀린 에러도 있을 수 있다. 책에서도 말하듯이 당황하지않고 디버깅을 하는 것이 가장 좋은 태도인 것 같고, 자주 쓰는 방법으로는 에러가 난 부근에서 에러를 잡기 위해서 관련된 여러 변수들을 출력해보면서 어떠한 값이 어떻게 들어가고 이게 어떻게 되서 여기서 문제가 생길 수 있는 지를 의심스럽게 하나씩 확인해본다. 그리고 단순 에러가 아니고 나의 접근 방식이 틀려서 생긴 에러는 다시 다른 방식의 접근으로 시도해야할 것이다.

- 텍스트 처리  
 텍스트 처리의 경우, 파일을 읽어드리고 이미 시중에 많이 나온 메소드를 사용하거나 아니면 내가 만든 모델을 거쳐서 원하는 텍스트로 가공시키느 경우도 있을 것이고, 파일을 하나 생성해서 값을 넣어서 저장시키는 경우도 있을 수 있겠다. 책에서는 파이썬의 언어에 대한 설명보다 다른 언어에 대한 설명이 많이 적혀있어서 완벽하게는 이해를 못하겠으나 텍스트를 구조적으로 다룰 수 있는 파이썬에서는 텍스트를 슬라이싱하거나 여러 나라의 언어로 디코드를 한다는 등의 일을 할 수 있다.

- 코드 생성기  
 코드 생성기는 다른 말로 하면 자동화 프로그래밍이라고도 할 수 있다고 생각한다. for구문이 아닌 좀더 체계적인 자동화 프로그래밍을 배우고 싶다는 생각을 이전부터 많이 했고 실제로 내가 진행했던 프로젝트에서도 매우 중요한 역할을 해주어서 필요한 능력이라고 많이 생각하는 부분이다.


### 4. 실용주의 편집증
현실 하에서 실용주의 프로그래머는 "완벽한 소프트웨어는 만들 수 없다"라는 것을 어떻게 장점으로 바꿀 수 있는 지를 얘기한다. 또한 이 파트에서 처음으로 실용주의 프로그래머들은 '그들은 자기 자신 역시 믿지 않는다'라는 말이 나오는데 이는 어느 누구라도 완벽한 코드를 짤 수 없기 를 알기 때문에 본인의 실수 또한 대비하여 방어적으로 코드를 짠다는 말이다. 이 말은 다른 파트에서 다시 나올 정도로 굉장히 책에서 강조하는 말이다.
- DBC(Design By Contract)  
세상에 완벽한 소프트웨어는 없다. 우리가 잘 사용하는 소프트웨어가 불완벽한 것인데 어떻게 소프트웨어가 잘 사용될 수 있는 거고 어떻게 돈을 받고 팔 수 있는 것일까라고 의문을 가진다면 책에서는 계약에 의한 설계라고 말한다. 계약에 의한 설계란, 버트란드 마이어라는 사람이 아이펠이라는 언어를 만들면서 개발한 개념이다. 이 개념은 프로그램의 정확성을 보장하기 위해 소프트웨어 모듈들의 권리와 책임을 문서화하는 데에 초점을 맞춘다. 여기서 정확한 프로그램은 완벽한 프로그램과는 다른 의미로, 프로그램이 스스로 자신이 하는 일이라고 주장하는 것보다 많거나 적지도 않게 딱 그만큼만 하는 프로그램을 말한다고 책에서 설명하고 있다. 즉, 계약으로 맺은 요구사항만은 정확하게 실행을 하는 것이다 서브클래스의 생성 등 세부적인 것에는 계약 당사자들은 터치하지 않는다. 오로지, 요구된 기능들이 잘 실행되는 지가 중요하다.

  - 루프 불변식  
  단순하지 않는 반복식에서는 들어오는 인풋값에 따라 유동적으로 실행될 수 있도록 짜야한다고 말한다.

  - 의미론적 불변식  
  기업측에서 새로운 경영진으로 바뀔 수 있는 가능성이 있고, 이럴 때 계약한 바와 또 다른 정책이 적용될 수 있는데 이러한 일시적인 정책에 영향을 받으면 안 된다. 그래서 계역을 할 시에 명확하고 모호한 점이 없게 진술하도록 노력해야한다고 한다.

- 일찍 작동을 멈추게 하라  
문제가 발생하면, 일찍 시스템을 멈추어야한다. 그런 일은 절대 일어날 리없다는 생각에 갇혀서 문제를 방치하는 상황이 없도록 하고 어떤 문제든 에러가 발생하면, 시스템을 스탑하고 디버깅을 실시해야한다. 갑작스런 중지에, 자원이 해체되지 않았을 수도 잇고, 다른 프로세스들과 상호작용이 더 필요할 수는 있으나 이미 유효하지 않는 프로그램으로 되ㄹ도록 빨리 종료해야한다.

- 단정적 프로그래밍  
단정문(assert문)을 사용해서 나만의 착각인 '이런 일은 절대 일어날리 없어'를 벗어나도록 하자. 나의 단정이 아닌 컴퓨터의 단정이 더 정확하기 때문에 보다 가치 있다. 단정문은 알고리즘의 동작을 검사하는데 유용하게 쓰일 수 있다. 단정은 결코 일어나면 안 되는 것들을 검사하는 것이다. 개인적으로  나는 assert문을 자주 써본 경험은 없다. 아쉽게도 책에서도 예시들이 자바(Java)로 구현되어있음이 아쉽다. 하지만 왜 단정문이 필요하고 어떤 경우에 단정문을 쓰면 좋은 지 이해할 수 있게 되어 좋았다.

- 리소스 사용의 균형  
코딩할 떄 우리는 모두 리소스(메모리, 트랜잭션, 쓰레드, 파일, 타이머 등)를 관리한다. 리소스를 할당하고, 사용한 다음, 해제하는 순서를 따른다. 하지만 대다수의 개발자들은 리소스 할당과 해제를 다루는 일관된 계획을 갖고 있지 않지만 책에서는 "시작한 것은 끝내라"라는 팁을 주어 어찌보면 넓은 바운더리를 정해주었다고 생각한다.
한 번에 하나의 리소스를 필요하는 루틴에 대해 책에서 제안한 2가지이다.
  1. 리소스를 할당한 순서의 반대로 해제하라. 이렇게 해야 한 리소스가 다른 리소스를 참조하는 경우에도 리소스를 고아로 만들지 않는다.

  2. 코드의 여러 곳에서 동일한 리소스 집합을 할당하는 경우, 할당 순서를 언제나 같게 하라. 교착 가능성이 줄어들 것이다.   

  어떤 정류의 리소스를 사용하고 있는 지는 중요하지 않고 모든 리소스에 대해서 모두 기본 패턴이 적용된다. 또, 리소스를 할당하는 것이 누구이든, 그 리소스를 해제할 책임까지 져야 이 개념을 더 발전시킬 수 있다고 한다.  
파이썬을 사용한 프로그래밍에서는 리소스를 클래스 안에 캡슐화하는 것이 유용하다고 느낀다. 특정 리소스 타입이 필요할 때마다 그 클래스의 객체를 생성하면 되고 그 객체가 스코프를 벗어나거나 가비지 콜렉터가 객체를 수거해 가면 객체의 소멸자가 클래스로 감싸진 리소스를 해제한다.  
마지막으로, 실용주의 프로그래머는 자신을 포함해서 아무도 믿지 않기 때문에, 정말로 리소스가 적절하게 되었는 지 실제로 점검하는 코드를 늘 작성하는 것이 언제나 좋다고 생각한다고 책에서 주장한다.


### 5. 구부러지거나 부러지거나
이 파트에서는 되돌릴 수 없는 의사 결정을 내릴 수있는 구체적인 방법에 대해 설명한다. 이를 잘 활용하면 불확실한 상황에 닥쳐도 코드의 유연성과 적응성을 잃지 않게 될 것이다.

- 결합도 줄이기  
코드를 모듈로 구성하고, 이들 간의 상호작용을 제한하기 위해서 모듈간의 의존 정도를 의미하는 결합도에 대해 살펴볼 필요가 있다.  결합도를 줄이게 되면 한 모듈이 변경되거나 교체된다는 등 여러가지 수정상황이 발생했을 때 다른 모듈들은 변경 없이 수행될 수 있을 것이다. 그렇다면 결합도를 줄이기 위해서 디미터 법칙을 사용해서 메서드, 함수를 설계한다. 디미터 법칙이란 한 객체가 제공하는 메서드에 접근하기 위해 또 다른 객체들은 통하는 것을 허용하지 않는다는 법칙이다. 이 법칙은 코드를 더 유연하고 강하게 만들어주지만 많은 함수들이 생성되고 그 속의 요청을 전달해주어야하는 메서드까지 고려한다면 어떤 어플리케이션인지에 따라 이 법칙을 적용하는 것이 좋을 수도 있고 오히려 매우 나쁠 수도 있다. 무조건 결합도를 줄이는 것이 좋은 것이 아니라 본인의 어플리케이션이 어떠한 특성을 지니고 있는 지를 정확히 파악해서 효율적으로 다루어야한다.

- 메타프로그래밍  
코딩 중 세부사항은 전체 코드를 어질러 놓아 코드의 가독성을 떨어뜨린다. 그리고 코드도 매우 길어질 수 있다. 진짜 중요한 알맹이 코드와 세부사항의 껍질 코드를 따로 분리한다. 즉, 일반적인 경우에 대해서 프로그램을 만들고, 특별한 것은 컴파일 된 코드 밖 어딘가에 빼놓는다. 이렇게 하면 설계의 결합도가 줄여져서 더 유연한 프로그램을 만들 수 있고 알맹이 코드를 보다 강하게 디자인할 수 있다는 이점이 있다. 또한 애플리케이션을 커스터마이징하기 위해 다시 컴파일할 필요가 없다.
나는 이 메타프로그래밍을 읽고 가장 먼저 떠오른 것은 웹 프로그래밍이었다. 세부적인 디자인 관련 코드와 추상화 코드를 분리함으로써 원하는 디자인에 따라 디자인 코드만을 간단하게 수정할 수 있어 간편했었던 경험이 떠올랐다. 그리고 단순 프로그래밍에서도 너무 긴 코드를 두 개의 코드로 분리해서 호출하여 사용하였던 경험 또한 생각이 났다.

- 시간적 결합   
여기서 시간은 데드라인이 아니고 소프트웨어의 설계 요소 자체로서의 시간이다. 코딩을 할 때, 사람들은 마치 직렬 연결처럼 짠다. 하지만 실제로 효율적인 것은 병렬연결이다. 코드를 병렬로 연결한다는 것은 시간의 절약을 가져온다. 동시에 여러가지의 일을 하는 것은 프로그래밍에서 쓰레드 개념을 사용할 수 있다. 이렇게 쓰레드를 사용한 프로그래밍은 코드를 병렬적으로 실행하하여 독립적이고 동시적인 객체를 만들 수 있다. 이 글을 읽으면서, 나도 굉장히 직선적으로 코딩을 한다는 생각이 들어 반성하게 되었다.

- 뷰  
프로그램을 여러 모듈로 나눈 다음, 객체가 서로에 대해 너무 많이 알기를 원치 않으므로 이벤트를 이용해서 어떤 객체의 상태 변화를 이에 관심을 가질 다른 객체들에 알려준다. 이렇게 하면 객체들 사이의 결합을 최소화할 수 있다. 그래서 모델, 모델을 표시하는 뷰 그리고 뷰를 관리하는 컨트롤러에서 모델을 분리해낸다. 이것을 MVC(Model-View-Controller)의 개념이다.
  - 모델 : 대상 객체를 나타내는 추상 데이터 모델. 모델은 어떤 뷰나 컨트롤러에 대해서도 직접적인 지식을 지니지 않는다.
  - 뷰 : 모델을 해석하는 방법. 뷰는 모델의 변화 그리고 컨트롤러가 보내는 논리적 사건을 구독한다.
  - 컨트롤러 : 뷰를 제어하고 모델에 새로운 데이터를 제공하는 방법. 모델과 뷰 둘 모두에 이벤트를 보낸다.    

  덧붙이자면, 컨트롤러는 조정 작용을 하는 메커니즘이고, 어떤 입력 장치와 꼭 연결시켜 생각하지 않아도 된다. 그래서 모델-뷰 네트워크 설계 기법도 있다. 이 기법은 책에서 나온 예시로 이해하기 쉬웠는데 간단히 요약하자면 많은 정보를 사용자가 알 필요는 없으니, 가장 이슈되는 정보만을 사용자에게 보여주는데 하나의 모델에 여러 뷰가 생길 수 있고, 뷰 하나에 여러 모델을 이용할 수 있다. 여기서 뷰는 문장생성 또는 비디오 자막 생성 등이 있다. 이렇게 모델에서 뷰를 분리함으로써 여러 방면으로 표현을 할 수 있다.

- 칠판  
칠판 시스템을 이용하면 객체들이 비동기적으로 데이터를 주고받는 공간이 생긴다. 이것은 객체들 사아의 결합을 완전히 끊을 수 있고 개발자 입장에서도 코드의 양을 줄일 수 있다. 칠판을 구현함으로써 데이터를 주고받는 것은 객체의 데이터 뿐만 아니라 객체 자체를 칠판에 저장할 수 있다. 그래서 객체의 흐름에 기반한 알고맂므을 설계하는 것에 칠판 시스템이 이용될 수 있다. 프로젝트가 큰 경우에는 칠판이 난잡해질 수 있어 불편한 경우가 있는데, 이 때에는 칠판을 여러 구획으로 나누고 어떤 방식으로든 자료를 정리하기 시작하는 것이 해결방법이라고 책에서 제안한다. 우선 칠판 시스템을 형사들의 칠판으로 비유함으로써 보다 이해하기 쉬웠고, 이러한 시스템을 사용하면 정말 많은 사람들이 하나의 공간에서 쉽게 서로가 원하는 데이터를 얻거나 또는 다른 사용자를 알 수 있거나 등을 할 수 있게 되어서 이 시스템은 하나의 플랫폼같은 성격을 지녔다고 생각한다.

### 6. 코딩하는 동안 해야 할 일들
코딩할 때는 매분마다 결정을 내려야 하는데, 프로그램이 정확하고 생산적으로 작동하기 위해서는 깊은 생각과 판단을 통한 결정이 필요하다. 코딩의 대부분은 반복적인 일이지만, 마음은 늘 깨어있도록 유지해야 재앙을 막을 수 있다고 이 파트에서 얘기한다.
- 우연적 프로그래밍  
우연에 맡기는 프로그래밍을 하지 말라라고 책은 말한다. 어쩌다가 우연히 된 코드가 이후 어쩌다가 안되면 우리는 해결할 수 없다. 왜냐하면 애초부터 그게 어떻게 돌아갈 수 있었는 지를 개발자가 몰랐기 때문이다. 만약 코드가 우연히 맞아떨어져서 실행이 되었다해도 우리는 항상 의도적인 프로그래밍을 해야한다. 나의 의도를 세우고 그것을 따라 코딩을 해야한다. 하지만 나는 내 의도대로 짜고 있는 와중에 우연찮게 코드가 실행이 됐을 때, 이것이 나의 지식이 부족해서 생긴 우연일 수도 있지않을 까라는 경우도 있지 않을까 생각한다. 내가 아직 배우고 있는 입장에서, 어떠한 코드가 우연찮게 돌아갔을 때, 혹시 내가 몰랐던 어떤 것들의 사용법, 개념 등이 우연히 구현이 되었고 그 코드를 하나씩 뜯어보면서 어쩌면 더 배울 수 있는 경우도 생기지 않을 까라는 생각이 들었다. 물론 책이 무엇을 말하고 있는지 알고 있지만 모든 우연이 모두 틀렸다는 가정은 개인적으로는 아닐 수 있다는 생각이 든다.

- 알고리즘의 속도  
추정의 또 다른 종류의 추정은 알고리즘이 사용하는 자원을 추정하는 것이다. 어떠한 알고리즘이 얼만큼의 시간, 프로세서, 메모리 등을 잡아먹냐에 따라서 어떤 알고리즘을 적용시킬 수 있을 지 의사결정할 수 있도록 도와주는 추정이다. 하지만 시간이 적게 걸린다고 무조건 좋은 알고리즘은 아니다. 종종 적당한 알고맂므을 선택하는 것도 실용적이다. 그러므로 성급한 최적화를 조심히라고 한다.

- 리팩터링  
코드를 다시 작성하기, 다시 작업하기, 다시 설계하기를 총괄해서 '리팩터링'이라고 한다. 리팩터링은 중복, 직교성이 좋지 않은 설계, 유효기간이 끝난 지식, 성능을 개선하려할 때 실시한다. 리팩터링을 시작하기 위해서는 굳은 결심을 해야하는데 피하지말고 해체해야한다고 한다. 일찍 리팩터링을 하지않는다면, 조금의 일은 점점 불어나 심각해지므로 일찍 리팩터링하고, 자주 리팩터링해야한다. 리팩터링은 천천히, 신중하게, 조심스럽게 진행해야하는 작업이다.   
마틴 파울러가 생각하는 리팩터링을 하기 위한 다음 몇 가지 간단하지만 중요한 조언 3가지는 다음과 같다.
  1. 리팩터링과 새로운 기능 추가를 동시에 하지 말자.
  2. 리팩터링을 시작하기 전 든든한 테스트 집합이 있는지 먼저 확인한다.
  3. 단계를 작게 나누어서 신중하게 작업한다.  

  예전에 리팩터링을 교수님께 배운 적이 있었는데 , 그 떄 굉장히 고치는 과정에서는 너무 복잡하고 많은 변수들이 존재했고 변수명까지 수정하면서 리팩터링을 진행했고 또 한 큐에 끝나는 것이 아니고 몇 일 정도로 이어지는 과정이다보니 흐름을 끊기게 되면 어디서부터 손을 다시 대야하는 지도 헤맸던 기억이 난다. 그 때 고칠 당시에는 더 너저분하다는 생각이 들었지만 나중에 고치고 깨끗해진 코드를 보니까 이걸 왜 해야하는 지도 알겠고 원본 코드보다 훨씬 좋은 코드인 걸 알 수 있었다. 그래서 리팩터링 과정이 굉장히 중요한 과정 중 하나라고 생각하고 한편으로는 어려운 과정이라고 생각한다.

- 테스트하기 쉬운 코드  
소프트웨어를 만들 때 맨 처음부터 테스트 가능성을 만들어 놓고, 코드들을 서로 연결하기 전에 코드를 하나하나 철저하게 테스트해야만한다. 어떤 모듈에게 이것저것을 시켜보는 코드를 단위 테스트라고 부른다. 단위 테스트는 일종의 인위적인 환경을 구축한 다음, 테스트할 모듈의 루틴들을 호출한다. 그런 다음 반환된 결과들을 이미 알고 있는 값과 비교해 보거나 똑같은 테스트를 이전에 돌렸을 때 나온 값과 비교해 보아서 올바른 지 검사한다. 하지만 그 전에 먼저 하나의 단위 차원에서는 어떤 것을 테스트해야할 지 결정해야한다. 단위 테스트를 진행하는 대부분의 이유는 코드가 계약을 지키는 지에 대한 여부 그리고 코드로 표현된 계약의 의미가 우리가 생각한 것과 일치하는 지에 대한 여부를 알 수 있기 때문이다. 하나의 모듈을 테스트할 때의 순서는 하부 컴포넌트들을 먼저 테스트하고 모두 검증을 끝낸 후에, 모듈 자체를 테스트 할 수 있다. 이렇게 계약을 잘 지키는지 테스트하는 것을 강조함으로써, 프로젝트 후반부에 발생할 수 있는 최악의 상황을 방지할 수 있다. 그래서 모듈을 설계할 때에는, 그것이 지켜야할 계획과 계약을 지키는지 테스트하는 코드와 함께 설계해야한다.  
그렇다면 단위테스트는 어떻게 작성해야하는가는 다음과 같다. 먼저, 프로젝트의 규모가 작을 땐, 모듈 안에 그 모듈의 단위 테스트 코드를 포함해 넣어도 된다. 프로젝트의 규모가 클 땐, 각각의 테스트를 하위 디렉터리로 옮겨 놓기를 제안한다. 테스트 코드를 찾기 편한 곳에 위치시켜야하는 것이 중요하다. 이렇게 해서 테스트 코드를 쉽게 접근할 수 있도록 하는 것은 다음의 2가지 자원을 제공하는 것이다.

  1. 여러분 모듈의 모든 기능을 어떻게 이용해야하는 지 보여주는 예제
  2. 후일 코드 변경 시 검증하기 위한 회귀 테스트를 구축할 수 있는 수단     

  파이썬에서는 상태를 기록으로 남기거나, 예상 결과값에 비추어 출력을 분석하거나, 테스트를 선택하고 실행하는 일처럼 자주 쓰이는 작업 기반의 클래스를 만들곤 한다. 개별 테스트들은 이 기반 클래스에게서 상속받아 구체적인 테스트 코드를 추가하면 된다. 이러한 장치에는 다음과 같은 기능이 필요하다.
  1. 시작할 때 할 일과 마칠 때 할 일을 지정할 수 있는 표준적인 방법
  2. 개별적인 테스트들을 선택하거나, 아니면 모든 테스트를 한꺼번에 선택하게 해주는 메서드
  3. 예상한 결과에 비추어 결과를 분석할 수 있는 방법
  4. 실패를 보고하는 표준화된 형태

 하지만 테스트 집합이 좋더라도 모든 버그를 발견하지 못할 수 있다. 소프트웨어가 배치된 후에도 테스트해야만 하는 경우가 자주 발생한다. 이런 종류의 메커니즘으로는 추적 메시지를 담아 도는 로그 파일, 단축키, 웹 서버를 내장시켜 작업 상태를 점검하는 수단을 제공하는 것 등이 있다.  
 테스트는 기술적이라기보다는 문화적인 것이다. 테스트를 함으로써, 유지보수비용과 문의전화를 줄이는데 많은 발전을 거둘 수 있기 때문에 소프트웨어를 철저하게 테스트할 계획을 세우는 것이 좋다.   

### 7. 프로젝트 전에

성공적인 프로젝트를 위해 프로젝트가 시작하기 전에 몇 가지 기본 원칙을 정해야할 필요가 있다는 것을 알려주는 파트이다.
- 요구사항   
요구사항은 세부적인 것보다 추상적인 것이 좋다. 추상적인 요구사항을 구현하기 위해서 가장 좋은 방법은 사용자가 되어 보는 것 또는 사용자와 함께 일해보는 것이다. 사용자의 입장에서 요구사항을 이해하고 구현을 한다면 보다 완성적인 프로그램을 만들어낼 수 있을 것이다. 완성적인 프로그램이란 사용자가 잘 쓸 수 있도록 잘 적응 할 수 있는 것이다.   
그리고 프로젝트 시작 전, 프로젝트에서 쓰일 용어들에 대한 정의를 문서로 정리하여 프로젝트에 참여하는 모든 사람들과 용어를 맞춘다. 이렇게 되면 프로젝트 진행 중, 같은 것을 다르게 말해서 생기는 문제는 발생하지 않을 것이다.

- 창의적인 문제 해결  
프로젝트 진행 중 정말 어려운 문제에 직면할 경우가 있다. 이럴 때, 생각의 틀에서 벗어나서 해법을 찾아나가는 것이 아니라 이 문제에 대한 틀이 어디까지인 지를 찾아야한다. 그 틀이 곧 이 문제에 대한 진짜 제약일 것이니 말이다. 제약을 찾을 때는 가장 구속이 심한 제약부터 찾아나가기 시작해야한다. 그리고 그 제약들을 범주별로 나누고 우선순위를 매겨서 해법을 찾아나가야한다. 해법이 무엇인가를 찾는 것이 아니고 혹시 이렇게 푸는 것이 아니고 또다른 쉬운 방법이 있지는 않을까라는 생각이 들 때가 있다. 그렇다면 스스로 많은 질문들을 던지게 되는 게 그 과정속에서 갑자기 깨달아지는 경우가 많다. 나도 이러한 비슷한 경험이 있다. 무슨 일을 하다가 막혔을 때, 나의 로직이 잘 못 됐고 또 다른 로직이 있을 수도 있다는 의심이 들었을 때, 과연 내 로직이 잘못되었고 정말 더 좋은 로직이 있는 가에 대한 많은 질문을 던진다. 그 질문에 대한 답을 찾아가면서 나의 원래 로직이 지금은 막혀있어도 이것이 답일 것이다라고 판단이 내려질 때가 있고 유레카!처럼 다른 대안이 떠오를 때가 있다. 책에서 "우리에게 필요한 것은 진짜 제약과 우리를 오도하는 제약 그리고 그 차이를 구별하기 위한 지혜다."라는 인상적인 문장이 있다. 여기서 말하는 지혜를 얻기 위해선, 많은 제약들을 보고 구별해보는 경험들이 있어야할 것이라고 생각이 든다.  

- 시작의 두려움  
준비가 되었을 때 시작하라. 무작정 프로젝트를 두려운 마음, 미루고 싶은 마음으로 시작하지 말고, 이제 하고 싶다, 이제 해야겠다 라는 마음으로 프로젝트의 첫 시작을 하는 것이 바람직하다. 그렇다면 이러한 시작의 두려움을 어떻게 해결할 수 있을까? 책에서는 프로토 타이핑을 추천한다. 프로토 타이핑이란 프로젝트 시작전 프로젝트의 개념 입증용 코드를 짜보는 것이다. 일단 연습삼아 시작한 이 일이 시간낭비같다거나 지루함을 느낄 때, 그 때, 진짜 프로젝트를 시작하면 된다. 프로토 타이핑의 이런 이점들에 덧붙여서 프로토 타이핑을 진행하면서 앞서 보이는 프로젝트의 문제들 등을 미리 만나볼 수 있다는 장점도 있다.   

- 명세의 함정  
프로그램 명세화란 어떤 요구사항을 가져와 프로그래머가 구현을 시작할 수 있는 시점까지 정리하는 과정이다. 명세화는 사용자의 필요를 명문화한 것이고, 최종 시스템이 그 요구사항과 일치할 거라는 암묵적인 계약이기도 하다. 명세서는 계속해서 작성된다. 왜냐하면 명세서가 시스템이나 그 시스템에 대한 요구사항의 모든 세부적인 사항과 미묘한 부분까지 모조리 설명할 수 있지 못하다. 그렇기 때문에 막상 구현을 해서 보여주면, 설계자는 구현에 대한 자신의 요구사항이 반영되지않은 부분에 대해 부족함을 느끼고 다시 명세서를 작성할 것이다. 그리고 명세서에 기술하는 언어적 표현에도 문제가 있다. 어떠한 일들은 언어로 설명하기 어려운 일들이 있기 떄문이다. 또 명세서가 너무 세부적이면 개발자가 건강한 개발을 할 수 없다. 건강한 개발이란 설계자가 말한대로 구현하고 싶지만 구현에도 요구사항이 있다면, 이런 식으로 구현이 되었음 하다고 명세서에 기술되어있다면 개발자들은 그렇게 진행해야한다. 하지만 세상에는 그 방법말고 또 효율적이고 효과적인 방법들이 있을 수 있다. 이러한 부분에서 좋은 방법들은 제쳐두고, 설계자가 요구한 방법만을 써야한 다는 것은 건강한 개발이 아니다. 그러므로 명세서는 아까 말했듯이 세부적인 것보다 추상적으로 진행을 해야한다. 이는 마치 이음새가 없는 접근방식이라고 할 수 있겠다.   
이렇게 명세서를 작성하는 일이 계속해서 이루어진다면 구현의 시작 시간이 많이 미루어질 것이다. 이렇게 명세의 순환에 갇혀있지말고 언제가는 코딩을 시작해야하기 때문에 프로토 타이핑을 해보거나, 예광탄 개발을 고려해야한다.  

- 형식적 방법  
형식적 방법이란 소프트웨어 공학에서 수학에 기반을 둔 딱딱한 기법들을 말허간 형식적인 면이 강조된 방법을 총칭하기도 한다. 예로 들어, 다이어그램과 거기에 추가된 설명의 조합을 이용한 요구사항이 있다. 다이어그램과 설명의 조합은 곧 설계자의 설명으로 들어야하는 데 이것은 사실 구식의 글로 써진 요구사항과 다를 바가 없다. 물론 어떤 점에서 이런 요구사항을 나타내는 방식이 이점이 있을 수 있지만 가능하다면 사용자에게 프로토타입을 보여주고 직접 다뤄보게하는 편을 선호한다. 또한 형식적인 방법을 사용하면, 누구는 이걸하고 다른 누구는 저걸하고하면서 집단을 분리하여 일을 맡기게 된다. 이렇게 되면 의사소통의 부재가 발생하게 된다. 그리고 설계자와 개발자 사이로 분리된 사고방식이 생길 수 있다. 그것이 아니라 모두가 전체적인 시스템을 이해하는 것이 중요하다. 물론 모든 것을 완벽하게 이해하는 것은 힘들 것이나, 어떠한 것이 어떻게 상호작용을 하고, 이 데이터는 어디에 있는 지, 요구사항은 뭔지 등은 알아야한다. 마지막으로 형식적 방법을 사용하면 구현 중에 문제가 생길 수 있다. 동적으로 연결해야 할 객체들 사이에 동적인 관계가 아닌 정적인 관계를 설정하도록 권장할 것이기 때문이다. 이러한 점들 때문에 형식적 방법의 노예가 되지 말라고 책에서 말하고 있다.   
형식적 방법의 노예가 되지 말라는 것은 형식적 방법을 사용하지 말라는 것이 아니다. 형식적 방법을 사용하되, 실용주의 프로그래머들은 방법론을 비판적인 시각으로 바라본 다음, 각각의 방법론에서 가장 좋은 것만 뽑아 매달 점점 좋아지는 자신의 작업 실천 방법의 집합 속에 녹여 넣는 것이 핵심이다. 자신의 공정을 개선하고 다듬기 위해 끊임없이 노력해야한다.    

### 8. 실용주의 프로젝트
이 파트는 프로젝트의 성패를 좌우하는 핵심 몇 가지에 대해서 얘기한다. 앞선 파트에서 나온 개념들이 다시 나오고, 그 모든 것이 실용주의라는 하나를 말하는 것이라고 느꼈다.

- 실용주의 팀   
  - 품질  
  팀 전체가 아무도 고치려고 하지 않는 사소한 결점을 용납하지 말아야한다. 품질은 팀원 전체가 개인적으로 기여할 때만 보장되는 것이다.

  - 삶은 개구리  
  삶은 개구리는 서서히 변하는 환경에 감지 못한 냄비에 갇힌 개구리가 결국 삶아지는 것이다. 개인보다는 팀이 삶은 개구리가 되기 쉽다. 제아무리 단단히 통제되는 팀이라도 자기네 프로젝트가 심각하게 변화하는 것에 대해 둔감할 수 있다. 모든 사람은 적극적으로 환경변화를 감시해야한다.

  - 소통  
  훌륭한 팀은 모든 사람이 좋아할 만한 잘 준비된 퍼포먼스를 보게 될 걸 알기 때문에 사람들은 회의를 기대한다. 그들이 생산해 내는 문서는 깔끔하고 정확하고 일관적이다. 팀이 하나로서 의사소통하게 도와주는 간단한 마케팅 비결로는, 프로젝트를 시작할 때 이름을 지어주는 것이다. 그렇게 되면, 팀은 정체성 확립의 기반을 얻을 것이다.

  - 반복하지 마라  
  팀원 간의 중복된 일을 제거하는 것은 어렵다. 중복은 노력을 낭비하게 하고 유지보수를 필요로 한다.

  - 직교성  
  팀을 기능적으로 분리하는 것을 선호한다. 사람들을 작은 팀으로 나누고, 각 팀은 최종 시스템의 특정한 기능 측면에 대해 책임지도록 한다. 이렇게 분리하면, 어떤 변화가 생기더라도 전체가 영향받는 일이 없게 된다. 그러나 이 기법은 책임감 있는 개발자들과 강력한 프로젝트 관리가 있을 경우에만 효과가 있다.

  - 자동화   
  일관성과 정확성을 보장하는 훌륭한 방법은, 팀이 하는 모든 일을 자동화하는 것이다. 자동화는 모든 프로젝트팀에게 필요불가결한 요소이다.

  - 개인 존중  
  팀은 개인들로 이루어져있다. 각 팀원이 자신의 방식대로 빛나게 해주어야한다.  
- 유비쿼터스 자동화  
  반복적이고 지루한 작업은 컴퓨터에게 시킨다. 우리는 그것보다 더 중요하고 어려운 일들이 있다. 자동화를 하는 데 자동화 도구를 사용해서 작업해야한다. 자동화를 하면 프로젝트 예산의 얼마만큼을 관리 절차에서 절약할 수 있다.

  - 빌드 자동화  
    빌드는 비어 있는 디렉터리 하나를 가지고 프로젝트를 밑바닥에서부터 만드는 과정이다. 대다수 프로젝트에서는 빌드를 매일 밤 자동으로 실행한다. 야밤의 빌드는 개인이 프로젝트의 특정 부분을 빌드하는 동안 실행하는 테스트보다는 더 완전한 테스트들을 실행한다. 중요한 점은 전체 빌드가 모든 테스트를 거치도록 하는 것이다.   


- 가차없는 테스트   
일찍 테스트하고, 자주 테스트하고, 자동으로 테스트하라. 코드를 작성하자마자 테스트해야한다. 자동화된 테스트를 사용하는 팀이 성공할 확률이 높다. 버그가 빨리 발견될수록 고치는 비용이 작아진다. '코드 조금, 테스트 조금'이라는 유명한 격언이다. 이 개념을 지속적인 통합, 가차없는 테스트라고 부른다. 테스트를 통과했다는 것은 그 코드가 '완료되었다'라고 말할 수 있는 높은 확신을 갖게 하는 것이다. 마지막으로 중요한 것은, 현존하는 테스트의 그물을 빠져 나가는 버그가 있으면, 다음번에는 그걸 잡아낼 수 있도록 새 테스트를 추가해야한다.

  1. 무엇을 테스트 할 것인가  
    - 단위 테스트  
    하나의 모듈을 테스트하는 코드이다.

    - 통합 테스트   
    프로젝트를 구성하는 주요 서브시스템이 다른 부분과 제대로 작동하는 지 보여줄 수 있는 코드이다. 단위 테스트의 확장에 지나지 않는다.

    - 유효성 평가와 검증  
    최종 사용자의 접근 방식에 대해, 그리고 그것이 개발자 테스트 데이터와 어떻게 다른 지에 대해 관심을 기울여야한다.

    - 자원 고갈, 에러, 그리고 복구  
    이상적인 상황에서 시스템이 올바르게 작동한다는 확신이 섰다면, 시스템이 실세계의 상황에서 어떻게 작동할지도 알아야한다. 실세계에서는 프로그램은 무한한 자원을 보장받지 못한다.  

    - 성능 테스트  
    소프트웨어가 실세계 조건에서 성능 요구사항들을 만족하는 지 자문해봐야한다.

    - 사용편의성 테스트  
    실제 환경의 조건 하에서 실제 사용자들이 시행한다. 사용편의성 테스트는 보정할 시간이 있을 때에 되도록 일찍 시행해야한다. 사용편의성 기준을 충족하지 못하는 것은 커다란 버그가 될 것이다.

  2. 어떻게 테스트할 것인가   
    - 회귀 테스트  
    회귀테스트는 이전 값과 현재 출력 값을 비교한다. 새로운 코드를 개발하면서 이전의 것을 잃지 않았다는 것을 확신시켜 주는 회귀 테스트로써, 중요한 안정망으로써, 실행할 수 있다.

    - 테스트 데이터  
  실세계 데이터와 합성 데이터라는 두 종류의 테스트를 실행할 데이터가 있다. 이 두 데이터가 갖는 다른 특징들이 소프트웨어에서 다른 종류의 버그를 노출시켜주기 때문이다. 실세계 데이터는 현실에서, 합성 데이터는 어떤 통계적 조건하에서 인공적으로 생성된다.

    - GUI 시스템 테스트  
    GUI 비중이 큰 시스템을 테스트하려면 많은 경우 특화된 테스트 도구가 필요하다. 하지만 모든 걸 자동화할 수는 없어, 그런 상황에서는 테스트 결과를 수작업으로 해석해야한다.  

    - 테스트를 테스트하기  
    파괴자를 써서 테스트를 테스트해야한다. 프로젝트 파괴자의 역할은 소스 트리의 카피를 별도로 만들어 취한 다음, 고의로 버그를 심고 테스트가 잡아낼 지 검증하는 것이다.  

    - 철저한 테스트  
    테스트가 철저했는 지는 지금도, 앞으로도 알 수 없다. 하지만 이것에 도움이 되는 상품이 있다. 커버리지 분석 도구는 테스트 중에 코드를 지켜보고, 코드의 어느 라인이 실행되지 않았는 지 기억한다. 모든 라인이 실행될 지라도, 중요한 것은 프로그램이 갖는 상태의 개수이다. 상태는 코드 라인들과 동등하지 않다. 그렇기 때문에 코드 커버리지보다 상태 커버리지를 테스트해야한다.  

  3. 언제 테스트할 것인가  
    실제 제품에 들어갈 모든 코드는 나오자마자 테스트해야한다.   

- 글쓰기  
문서가 애초부터 전체의 일부가 되게 하고, 나중에 집어넣으려고 하면 안된다. 프로젝트에서 생상되는 문서에는 기본적으로 내부와 외부의 두 종류가 있다. 내부 문서에는 소스코드, 주석 , 설계와 테스트 문서 등이 포함된다. 외부문서에는 사용자 매뉴얼 같이 외부 세계로 출간되거나 출하되는 모든 것이 포함된다.   
  - 마크업  
  규모가 큰 문서화 프로젝트에서라면 현대적인 문서 마크업체계를 사용할 것을 책에서 권한다.


- 위대한 유산   
현실적으로 프로젝트의 성공은 사용자들의 기대를 얼마나 잘 충족하는가에 따라 측정된다. 책에서는 '사용자의 기대를 부드럽게 넘어서라'라는 팁을 준다. 사용자의 기대를 부드럽게 넘어가기 위해서 기대 관리를 한다. 기대관리란 사용자가 시스템에서 무엇을 얻기를 기대해야 할지에 대해 적극적으로 제어하는 것이다. 사용자의 희망을 제어하는 것이 아니라, 사용자와 협동해서, 사용자가 아직 얘기하지않은 기대까지 포함해서, 개발 과정과 최종 전달물에 대한 공통된 이해에 도달하는 것이다. 이 프로세스를 용이하기 위해서 회사와 사용자들이 서로 소통해야한다. 어떤 기능이 진정 사용자를 기쁘게 할 것인지 단서를 잡아내기 위해서 프로젝트 진행 중에 사용자의 말을 기울이는 것이 좋다. 그리고 그들이 기대하는 것보다 조금만 더 해주는 것이 좋다. 그렇다면 약간의 노력을 들여 시스템에 사용자 편의를 위한 기능을 추가한다면, 관계가 두고두고 좋아질 것이다.

- 오만과 편견  
실용주의 프로그래머들은 그들의 작품에 서명한다. 어떤 프로젝트에서는 코드 소유권 때문에 협력에 차질이 생길 수도 있다. 하지만 그것보다는 서로가 서로의 코드를 존중해야한다. 익명성은 특히 큰 프로젝트에서 적당주의, 실수, 태만 긜고 나쁜 코드의 번식지가 될 수 있다. 코드에는 주인이 있어야하지만 꼭 개인일 필요는 없다. 실제로 공동 소유권을 갖는 코드도 있다. 서명은 품질의 보증수표로 인식되게 해야한다. 사람들이 코드에 붙여진 이름을 보고 그것이 튼튼하고 잘 작성되고 제대로 테스트가 되었고, 또 훌륭히 문서화되었을 것이라고 기대하도록 만들자. 그것이 나를, 프로페셔녈한, 실용주의 프로그래머로 발전시킨다.
